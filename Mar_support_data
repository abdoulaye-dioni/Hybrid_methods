
  
############ Mécanisme mar dans  support data ####################

# sink("mar_support.txt")


library(Hmisc)
library(survival)
library(ggplot2)
library(survminer)
library(ggthemes)
library(splines)
library(mice)
library(mitml)
library(dplyr)




ti <- Sys.time()




getHdata(support)
getHdata(support2)






## Nétoyage des données


support.name <- names(support)
support.name










support2_data <- as.data.frame(lapply(support2, function(col) {
  if (inherits(col, "labelled")) {
    return(as.vector(col))
  } else {
    return(col)
  }
}))








mydata <- support2_data[,c("d.time","death","age","sex", "income", "dzgroup","num.co","meanbp","hrt", "crea", "sod","temp")]





mydata$meanbp <- ifelse(mydata$meanbp == 0, NA, mydata$meanbp)
mydata$hrt <- ifelse(mydata$hrt == 0 | mydata$hrt == 300, NA, mydata$hrt)



### Données d'études 



fulldata <- mydata[complete.cases(mydata),] 




dim(fulldata)





## Recodage de certaines variables



fulldata$death <- as.factor(fulldata$death)
#fulldata$id <- 1:nrow(fulldata)
levels(fulldata$income) <- c("<$11k", "$11-$25k",  "$25-$50k" ,  ">$50k")
fulldata$d.time <- fulldata$d.time/(30.4375*3) # Temps en trimestre
#fulldata$d.time <- fulldata$d.time/365.25 # Temps en année




summary(fulldata)



## Génération de données manquantes sous MAR avec mice

### Transformation de la variable `income` en variable indicatrice


data_dummies <- fulldata %>%
  mutate(across(c(death, sex, dzgroup, income), as.factor)) %>%  # S'assurer que les variables sont des facteurs
  mutate(
    death_0 = as.numeric(death == "0"),
    death_1 = as.numeric(death == "1"),
    sex_female = as.numeric(sex == "female"),
    sex_male = as.numeric(sex == "male"),
    dzgroup_A = as.numeric(dzgroup == "ARF/MOSF w/Sepsis"),
    dzgroup_B = as.numeric(dzgroup == "COPD"),
    dzgroup_C = as.numeric(dzgroup == "CHF"),
    dzgroup_D = as.numeric(dzgroup == "Cirrhosis"),
    dzgroup_E = as.numeric(dzgroup == "Coma"),
    dzgroup_F = as.numeric(dzgroup == "Colon Cancer"),
    dzgroup_G = as.numeric(dzgroup == "Lung Cancer"),
    dzgroup_H = as.numeric(dzgroup == "MOSF w/Malig"),
    income_A = as.numeric(income == "<$11k"),
    income_B = as.numeric(income == "$11-$25k"),
    income_C = as.numeric(income == "$25-$50k"),
    income_D = as.numeric(income == ">$50k")
  ) %>%
  select(-death, -sex, -dzgroup, -income)  # Supprimer les variables catégorielles originales









# Utilisation de la fonction ampute  (MAR)


mardata <- ampute(data_dummies,
                  prop=0.3,
                  patterns = matrix(c(rep(1,ncol(data_dummies)-4),rep(0,4)), 
                                    nrow = 1), 
                  mech = "MAR", 
                  weights = c(rep(1,ncol(data_dummies)-4),rep(0,4)))$amp




mardata <- mardata %>%
  mutate(
    death = case_when(
      death_0 == 1 ~ "0",
      death_1 == 1 ~ "1",
      TRUE ~ NA_character_
    ),
    sex = case_when(
      sex_female == 1 ~ "female",
      sex_male == 1 ~ "male",
      TRUE ~ NA_character_
    ),
    dzgroup = case_when(
      dzgroup_A == 1 ~ "ARF/MOSF w/Sepsis",
      dzgroup_B == 1 ~ "COPD",
      dzgroup_C == 1 ~ "CHF",
      dzgroup_D == 1 ~ "Cirrhosis",
      dzgroup_E == 1 ~ "Coma",
      dzgroup_F == 1 ~ "Colon Cancer",
      dzgroup_G == 1 ~ "Lung Cancer",
      dzgroup_H == 1 ~  "MOSF w/Malig",
      TRUE ~ NA_character_
    ),
    income = case_when(
      income_A == 1 ~ "<$11k",
      income_B == 1 ~ "$11-$25k",
      income_C == 1 ~ "$25-$50k",
      income_D == 1 ~ ">$50k",  
      TRUE ~ NA_character_
    )
  ) %>%
  select(d.time, death, age, sex, income,  dzgroup,num.co, meanbp, hrt, crea, sod, temp)  # Réorganiser les colonnes






mardata$death <- factor(mardata$death, levels = levels(fulldata$death))
mardata$sex <- factor(mardata$sex,levels = levels(fulldata$sex))
mardata$dzgroup <- factor(mardata$dzgroup,levels = levels(fulldata$dzgroup))
mardata$income <- factor(mardata$income,levels = levels(fulldata$income))








## Ajout des termes quadratiques



fulldata$meanbp2 <- fulldata$meanbp^2
fulldata$hrt2 <- fulldata$hrt^2
fulldata$temp2 <- fulldata$temp^2
fulldata$sqrt_crea <- sqrt(fulldata$crea)



mardata$meanbp2 <- mardata$meanbp^2
mardata$hrt2 <- mardata$hrt^2
mardata$temp2 <- mardata$temp^2
mardata$sqrt_crea <- sqrt(mardata$crea)

mardata$R.income <- as.factor(ifelse(is.na(mardata$income),0,1))



### Proportion des observations censurées et manquantes



(sum(fulldata$death ==0)/nrow(fulldata))*100 #  censure



(sum(is.na(mardata$income))/nrow(mardata))*100 # manquante




## Full data (sans valeurs manquantes)





extract_linear_terms <- function(cox_model) {
  model_summary <- summary(cox_model)
  results_table <- as.data.frame(model_summary$coefficients)
  results_table$term <- rownames(results_table)
  linear_terms <- results_table[grep("linear|^(?!.*nonlin)", results_table$term, perl = TRUE), ]
  #row.names(linear_terms) <- NULL
  return(linear_terms)
}




bias_relative <- function(value,hat_estimate){
  return(((hat_estimate - value)/value)*100)
}




full.mod <- coxph(formula = Surv(d.time, death == 1) ~ income + sex + sod +  
                    temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup), data = fulldata, 
                  tt = function(x, t, ...) pspline(x + t, df = 3))









out.full <- extract_linear_terms(full.mod)








result.full <- cbind(
  "exp(coef)" = exp(out.full[,c("coef")]),
  "lower.95" = exp(out.full[,c("coef")] -qnorm(0.975) *out.full[,c("se2")]),
  "upper.95" = exp(out.full[,c("coef")] +qnorm(0.975)*out.full[,c("se2")]),
  "Pr(>|z|)" =  2 * (1 - pnorm(abs(out.full[,c("coef")]/out.full[,c("se2")]))),
  "CI_width" = 2*qnorm(0.975)*out.full[,c("se2")]
)




rownames(result.full) <- rownames(out.full)
result.full






## Completes cases anlysis: (MCAR)


mod.mcar <- coxph(formula = Surv(d.time, death == 1) ~ income + sex + sod +  
                    temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup), data = na.omit(mardata), 
                  tt = function(x, t, ...) pspline(x + t, df = 3))












out.mcar <- extract_linear_terms(mod.mcar)






# Utilisation des erreurs standard pénalisées


result.cc <- cbind(
  "exp(coef)" = exp(out.mcar[,c("coef")]),
  "lower.95" = exp(out.mcar[,c("coef")] -qnorm(0.975) *out.mcar[,c("se2")]),
  "upper.95" = exp(out.mcar[,c("coef")] +qnorm(0.975)*out.mcar[,c("se2")]),
  "Pr(>|z|)" =  2 * (1 - pnorm(abs(out.mcar[,c("coef")]/out.mcar[,c("se2")]))),
  "bias" = bias_relative(result.full[,1],hat_estimate = exp(out.mcar[,c("coef")])),
  "CI_width" = 2*qnorm(0.975)*out.mcar[,c("se2")]
)

rownames(result.cc) <- rownames(out.full)
result.cc







### Méthodes sémi-paramétrique: inverse de la probabilité pondérée (MAR)









kappa = 0.95 # paramètre de compromis

work.model <- glm(R.income ~ d.time + death + age + sex +  sod +  temp +
                    dzgroup + num.co + hrt +crea + meanbp, data = mardata, family = binomial)
predicted <-  pmax(pmin(predict(work.model, type = "response"), 0.99), 0.01)



# Poids pondérés pour les observations manquantes selon notre proposition


mardata$w_corrected <- ifelse(
  mardata$R.income == 1,
  1 / predicted, 
  kappa*1 + (1-kappa)*(1 / (1-predicted)))



# Poids classique pour les observations manquantes selon  iwp standard



mardata$w_standard <- ifelse(
  mardata$R.income == 1,
  1 / predicted, 
  1 / (1-predicted))








summary(mardata[mardata$R.income == 0, c("w_corrected", "w_standard")])



summary(mardata[mardata$R.income == 1, c("w_corrected", "w_standard")])



# Disttribution du poids pondéré vs poids standard



p1 <- ggplot(mardata, aes(x = w_corrected, fill = factor(R.income))) +
  geom_histogram(alpha = 0.5, bins = 30) +
  scale_fill_manual(values = c("green", "blue"), labels = c("R.income = 0", "R.income = 1")) +
  labs(title = "Histogram of Corrected Weight by Missing Income Indicator", 
       x = "Weight", y = "Count", fill = "Weight") + 
  theme_minimal(base_size = 10) +
  facet_wrap(~ R.income, scales = "free", 
             labeller = as_labeller(c("0" = "R.income = 0", "1" = "R.income = 1"))) +
  theme(plot.title = element_text(hjust = 0.5, size = 10, face = "bold"))


p2 <- ggplot(mardata, aes(x = w_standard, fill = factor(R.income))) +
  geom_histogram(alpha = 0.5, bins = 30) +
  scale_fill_manual(values = c("orange", "blue"), labels = c("R.income = 0", "R.income = 1")) +
  labs(title = "Histogram of Standard Weight by Missing Income Indicator", 
       x = "Weight", y = "Count", fill = "Weight") + 
  theme_minimal(base_size = 10) +
  facet_wrap(~ R.income, scales = "free", 
             labeller = as_labeller(c("0" = "R.income = 0", "1" = "R.income = 1"))) +
  theme(plot.title = element_text(hjust = 0.5, size = 10, face = "bold"))



gridExtra::grid.arrange(grobs = list( p1,  p2), nrow = 2)








mod.iwp <- coxph(formula = Surv(d.time, death == 1) ~ income + sex + sod +  
                   temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup), data = na.omit(mardata), 
                 tt = function(x, t, ...) pspline(x + t, df = 3),weights = w_corrected,robust = TRUE)










out.iwp <- extract_linear_terms(mod.iwp)






# Utilisation des erreurs stanadrd robustes


result.iwp <- cbind(
  "exp(coef)" = exp(out.iwp[,c("coef")]),
  "lower.95" = exp(out.iwp[,c("coef")] - qnorm(0.975)*out.iwp[,c("se(coef)")]),
  "upper.95" = exp(out.iwp[,c("coef")] + qnorm(0.975)*out.iwp[,c("se(coef)")]),
  "Pr(>|z|)" = 2 * (1 - pnorm(abs(out.iwp[,c("coef")]/out.iwp[,c("se(coef)")]))),
  "bias" = bias_relative(result.full[,1],hat_estimate = exp(out.iwp[,c("coef")])),
  "CI_width" = 2*qnorm(0.975)*out.iwp[,c("se2")]
)
rownames(result.iwp) <- rownames(out.full)
result.iwp








## Imputation multiple paramétrique (MAR)






mardata$cumhaz <- NA
fit <-  survfit(survival::Surv(d.time, death == 1) ~ 1, data = mardata, type = "fh")
time_indices <- match(mardata$d.time, fit$time)
mardata$cumhaz[!is.na(time_indices)] <- fit$cumhaz[time_indices[!is.na(time_indices)]]





M = 10 # Nombre d'imputation



mice_P_data <- mice(
  data= mardata[,c("cumhaz", "death", "age","sex","income","sod","dzgroup","num.co","hrt","temp","crea","meanbp")],  
  m = M,         
  maxit = 5,      
  method = c("norm","logreg","norm", "logreg", "polyreg", "norm", "polyreg","norm","norm","norm","norm","norm"),
  print = FALSE,
  seed = 10000
)








mice_P_data <-  lapply(1:M, function(m) {
  cbind(mardata[,c("d.time","sqrt_crea","temp2","meanbp2","hrt2")], mice::complete(mice_P_data, m))
})
mice_P_data <- mitml::as.mitml.list(mice_P_data)





miceP.model <- with(mice_P_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                         temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup), 
                                       tt = function(x, t, ...) pspline(x + t, df = 3)))








list_P_mod <- lapply(miceP.model,function(terme)
{ extract_linear_terms(terme)})





## Fonction qui combine les résulats selon la règle de Rubin (usage de Variances pénalisées)



combine_MI <- function(manyresult) {
  estimates <- list()
  penalize_variances <- list()
  
  for (i in seq_along(manyresult)) {
    estimates[[i]] <- manyresult[[i]][,c("coef")] 
    penalize_variances[[i]] <- (manyresult[[i]][,c("se2")])^2  
  }
  
  estimates_mat <- do.call(rbind, estimates)
  penalize_variances_mat <- do.call(rbind, penalize_variances)
  m <- length(manyresult)
  
  # Combiner les estimations et les variances avec la règle de Rubin
  Q_bar <- colMeans(estimates_mat)  # Moyenne des estimations
  U_bar <- colMeans(penalize_variances_mat)  # Variance intra-imputation (robuste)
  B <- apply(estimates_mat, 2, var) * (m / (m - 1))  # Variance inter-imputation
  T <- U_bar + (1 + 1/m) * B  # Variance totale combinée
  penalise_se <- sqrt(T)  # Erreur standard combinée
  
  # df: degrés de liberté de Rubin
  df <- (m - 1)*(1 + U_bar/B)^2
  
  # Calcul des intervalles de confiance
  CI_low_combined <- Q_bar - qt(0.975, df = df) * penalise_se
  CI_up_combined <- Q_bar + qt(0.975, df = df) * penalise_se
  
  # Calcul des statistiques de test
  z <- Q_bar / penalise_se
  P.value <- 2 * (1 - pnorm(abs(z)))  # p-value bilatérale
  
  # Résultat final sous forme de data.frame
  mar.est <- data.frame(
    Estimate = Q_bar,
    penalise_se = penalise_se,
    CI_low = CI_low_combined,
    CI_up = CI_up_combined,
    P.value = P.value
  )
  
  return(mar.est)
}






miceP.est <- combine_MI(list_P_mod)
result_miceP.est <- cbind(exp(miceP.est [,c("Estimate","CI_low","CI_up")]), "P.value" = miceP.est[,"P.value"])

result_miceP.est$biais <- bias_relative(result.full[,1],hat_estimate = result_miceP.est[,c("Estimate")])
result_miceP.est[,"CI_width"] <- result_miceP.est[,"CI_up"] - result_miceP.est[,"CI_low"] 
rownames(result_miceP.est) <- rownames(out.full)
colnames(result_miceP.est) <- colnames(result.cc)
result_miceP.est









## Imputation multiple non paramétrique (MAR)





RF_NP_data <- mice(
  data= mardata[,c("d.time", "death", "age","sex","income","sod","dzgroup","num.co","hrt","temp","crea","meanbp")],  
  m = M,         
  maxit = 5,      
  method = c("rf", "rf", "rf", "rf", "rf", "rf","rf","rf","rf","rf","rf","rf"),
  print = FALSE,
  seed = 10000
)








RF_NP_data <-  lapply(1:M, function(m) {
  cbind(mardata[,c("d.time","sqrt_crea","temp2","meanbp2","hrt2")], mice::complete(RF_NP_data, m))
})
RF_NP_data <- mitml::as.mitml.list(RF_NP_data)



rfNP.model <-  with(RF_NP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                        temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup),
                                      tt = function(x, t, ...) pspline(x + t, df = 3)))





list.NP_mod <- lapply(rfNP.model,function(terme)
{ extract_linear_terms(terme)})





rfNP.est <- combine_MI(list.NP_mod)
result_rfNP.est <- cbind(exp(rfNP.est [,c("Estimate","CI_low","CI_up")]), rfNP.est[,"P.value"])

result_rfNP.est$biais <- bias_relative(result.full[,1],hat_estimate = result_rfNP.est[,c("Estimate")])
result_rfNP.est[,"CI_width"] <- result_rfNP.est[,"CI_up"] - result_rfNP.est[,"CI_low"] 
rownames(result_rfNP.est) <- rownames(out.full)
colnames(result_rfNP.est) <- colnames(result.cc)

result_rfNP.est




# Méthodes hybrides `

## Hybride 1: MI paramétrique et MI non paramétrique (MAR)



P_NP_data <- vector("list", M)
for (i in 1:(M/2)) {
  P_NP_data[[i]] <- mice_P_data[[i]]
  P_NP_data[[i + (M/2)]] <- RF_NP_data[[i]]
}
P_NP_data <- mitml::as.mitml.list(P_NP_data)









P_NP_mod <- with(P_NP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                    temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup),
                                  tt = function(x, t, ...) pspline(x + t, df = 3)))




list.P_NP <- lapply(P_NP_mod,function(terme)
{ extract_linear_terms(terme)})




P_NP.est<- combine_MI(list.P_NP)
result_P_NP.est <- cbind(exp(P_NP.est [,c("Estimate","CI_low","CI_up")]), "P.value" = P_NP.est[,"P.value"])

result_P_NP.est$biais <- bias_relative(result.full[,1],hat_estimate = result_P_NP.est[,c("Estimate")])
result_P_NP.est[,"CI_width"] <- result_P_NP.est[,"CI_up"] - result_P_NP.est[,"CI_low"] 
rownames(result_P_NP.est) <- rownames(out.full)
colnames(result_P_NP.est) <- colnames(result.cc)

result_P_NP.est










## Hybride 2: MI paramétrique et IWP (MAR)




MI.P_IWP_data <-  lapply(1:M, function(m) {
  cbind(mice_P_data[[m]], mardata[, c("sqrt_crea","temp2","meanbp2","hrt2", "R.income", "w_corrected", "w_standard")])
})

MI.P_IWP_data <- mitml::as.mitml.list(MI.P_IWP_data)





MI.P_IWP_mod <- with(MI.P_IWP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                            temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup), tt = function(x, t, ...) pspline(x + t, df = 3),weights = w_corrected, robust = TRUE))




list.P_IWP <- lapply(MI.P_IWP_mod,function(terme)
{ extract_linear_terms(terme)})








## Fonction qui combine les résulats selon la règle de Rubin (usage de Variances robustes)


combine_MI_IWP <- function(manyresult) {
  estimates <- list()
  robust_variances <- list()
  
  for (i in seq_along(manyresult)) {
    estimates[[i]] <- manyresult[[i]][,c("coef")] 
    robust_variances[[i]] <- (manyresult[[i]][,c("se(coef)")])^2  
  }
  
  estimates_mat <- do.call(rbind, estimates)
  robust_variances_mat <- do.call(rbind, robust_variances)
  m <- length(manyresult)
  
  # Combiner les estimations et les variances avec la règle de Rubin
  Q_bar <- colMeans(estimates_mat)  # Moyenne des estimations
  U_bar <- colMeans(robust_variances_mat)  # Variance intra-imputation (robuste)
  B <- apply(estimates_mat, 2, var) * (m / (m - 1))  # Variance inter-imputation
  T <- U_bar + (1 + 1/m) * B  # Variance totale combinée
  Robust_se <- sqrt(T)  # Erreur standard combinée
  
  # df: degrés de liberté de Rubin
  df <- (m - 1)*(1 + U_bar/B)^2
  
  # Calcul des intervalles de confiance
  CI_low_combined <- Q_bar - qt(0.975, df = df) * Robust_se
  CI_up_combined <- Q_bar + qt(0.975, df = df) * Robust_se
  
  # Calcul des statistiques de test
  z <- Q_bar / Robust_se
  P.value <- 2 * (1 - pnorm(abs(z)))  # p-value bilatérale
  
  # Résultat final sous forme de data.frame
  mar.est <- data.frame(
    Estimate = Q_bar,
    Robust_se = Robust_se,
    CI_low = CI_low_combined,
    CI_up = CI_up_combined,
    P.value = P.value
  )
  
  return(mar.est)
}






P_iwp.est <- combine_MI_IWP(manyresult = list.P_IWP)
result_P_iwp.est <- cbind(exp(P_iwp.est[,c("Estimate","CI_low","CI_up")]),P_iwp.est[,c("P.value")])
result_P_iwp.est$biais <- bias_relative(result.full[,1],hat_estimate = result_P_iwp.est[,c("Estimate")])
result_P_iwp.est[,"CI_width"] <- result_P_iwp.est[,"CI_up"] - result_P_iwp.est[,"CI_low"] 
rownames(result_P_iwp.est) <- rownames(out.full)
colnames(result_P_iwp.est) <- colnames(result.cc)
result_P_iwp.est




## Hybride 3:  MI non paramétrique et IWP (MAR)




MI.NP_IWP_data <-  lapply(1:M, function(m) {
  cbind(RF_NP_data[[m]], mardata[, c("sqrt_crea","temp2","meanbp2","hrt2","R.income", "w_corrected", "w_standard")])
})

MI.NP_IWP_data <- mitml::as.mitml.list(MI.NP_IWP_data)



MI.NP_IWP_mod <-  with(MI.NP_IWP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                               temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup),
                                             tt = function(x, t, ...) pspline(x + t, df = 3),weights = w_corrected, robust = TRUE))







list.NP_IWP <- lapply(MI.NP_IWP_mod,function(terme)
{ extract_linear_terms(terme)})








NP_iwp.est <- combine_MI_IWP(manyresult = list.NP_IWP)

result_NP_iwp.est <- cbind(exp(NP_iwp.est[,c("Estimate","CI_low","CI_up")]),NP_iwp.est[,c("P.value")])

result_NP_iwp.est$biais <- bias_relative(result.full[,1],hat_estimate = result_NP_iwp.est[,c("Estimate")])
result_NP_iwp.est[,"CI_width"] <- result_NP_iwp.est[,"CI_up"] - result_NP_iwp.est[,"CI_low"] 
rownames(result_NP_iwp.est) <- rownames(out.full)
colnames(result_NP_iwp.est) <- colnames(result.cc)
result_NP_iwp.est







## Hybride 4: MI paramétrique, MI non paramétrique et IWP (MAR)




P_NP_IWP_data <- lapply(1:M, function(m){
  cbind(P_NP_data[[m]],mardata[, c("sqrt_crea","temp2","meanbp2","hrt2","R.income", "w_corrected", "w_standard")])
})
P_NP_IWP_data <- mitml::as.mitml.list(P_NP_IWP_data)




P_NP_IWP_mod <- with(P_NP_IWP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                            temp +temp2 + meanbp + meanbp2 + hrt +  hrt2 + crea + sqrt_crea + tt(num.co)  + tt(age) + strata(dzgroup),
                                          tt = function(x, t, ...) pspline(x + t, df = 3),weights = w_corrected, robust = TRUE))




list.P_NP_IWP <- lapply(P_NP_IWP_mod,function(terme)
{ extract_linear_terms(terme)})






P_NP_iwp.est <- combine_MI_IWP(manyresult = list.P_NP_IWP)

result_P_NP_iwp.est <- cbind(exp(P_NP_iwp.est[,c("Estimate","CI_low","CI_up")]),P_NP_iwp.est[,c("P.value")])

result_P_NP_iwp.est$biais <- bias_relative(result.full[,1],hat_estimate = result_P_NP_iwp.est[,c("Estimate")])
result_P_NP_iwp.est[,"CI_width"] <- result_P_NP_iwp.est[,"CI_up"] - result_P_NP_iwp.est[,"CI_low"] 
rownames(result_P_NP_iwp.est) <- rownames(out.full)
colnames(result_P_NP_iwp.est) <- colnames(result.cc)
result_P_NP_iwp.est




## Biais relatif en pourcentage



all_bias <- data.frame(Full = bias_relative(value = result.full[,"exp(coef)"],hat_estimate = result.full[,"exp(coef)"]),
                       CC =  result.cc[,"bias"],
                       Iwp =  result.iwp[,"bias"],
                       Mice.P =  result_miceP.est[,"bias"],
                       RF.NP =  result_rfNP.est[,"bias"],
                       Hybrid1 =  result_P_NP.est[,"bias"],
                       Hybrid2 =  result_P_iwp.est[,"bias"],
                       Hybrid3 = result_NP_iwp.est[,"bias"],
                       Hybrid4 =  result_P_NP_iwp.est[,"bias"])


knitr::kable(round(all_bias[c("income$11-$25k", "income$25-$50k", "income>$50k","sexmale","tt(age), linear","tt(num.co), linear","crea","hrt","temp","sod","meanbp"),],3))


## Largeur des intervalles de confiance


all_CI_width <- data.frame(Full = result.full[,"CI_width"],
                           CC =  result.cc[,"CI_width"],
                           Iwp =  result.iwp[,"CI_width"],
                           Mice.P =  result_miceP.est[,"CI_width"],
                           RF.NP =  result_rfNP.est[,"CI_width"],
                           Hybrid1 =  result_P_NP.est[,"CI_width"],
                           Hybrid2 =  result_P_iwp.est[,"CI_width"],
                           Hybrid3 = result_NP_iwp.est[,"CI_width"],
                           Hybrid4 =  result_P_NP_iwp.est[,"CI_width"])




knitr::kable(round(all_CI_width[c("income$11-$25k", "income$25-$50k", "income>$50k","sexmale","tt(age), linear","tt(num.co), linear","crea","hrt","temp","sod","meanbp"),],3))





tf <- Sys.time()
code_time <- tf - ti
code_time



# sink()




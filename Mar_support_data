
############ Mécanisme mar dans  support data ####################

# sink("mar_support.txt")


library(Hmisc)
library(survival)
library(ggplot2)
library(survminer)
library(ggthemes)
library(splines)
library(mice)
library(mitml)
library(dplyr)




ti <- Sys.time()




getHdata(support)
getHdata(support2)






## Nétoyage des données


support.name <- names(support)
support.name










support2_data <- as.data.frame(lapply(support2, function(col) {
  if (inherits(col, "labelled")) {
    return(as.vector(col))
  } else {
    return(col)
  }
}))








mydata <- support2_data[,c("d.time","death","age","sex", "income", "dzgroup","num.co","meanbp","hrt", "crea", "sod","temp")]
mydata$meanbp <- ifelse(mydata$meanbp == 0, NA, mydata$meanbp)
mydata$hrt <- ifelse(mydata$hrt == 0 | mydata$hrt == 300, NA, mydata$hrt)



### Données d'études 
fulldata <- mydata[complete.cases(mydata),] 
dim(fulldata)





## Recodage de certaines variables



fulldata$death <- as.factor(fulldata$death)
#fulldata$id <- 1:nrow(fulldata)
levels(fulldata$income) <- c("<$11k", "$11-$25k",  "$25-$50k" ,  ">$50k")
fulldata$d.time <- fulldata$d.time/(30.4375*3) # Temps en trimestre
#fulldata$d.time <- fulldata$d.time/365.25 # Temps en année

summary(fulldata)



## Génération de données manquantes sous MAR avec mice
### Transformation de la variable `income` en variable indicatrice


data_dummies <- fulldata %>%
  mutate(across(c(death, sex, dzgroup, income), as.factor)) %>%  # S'assurer que les variables sont des facteurs
  mutate(
    death_0 = as.numeric(death == "0"),
    death_1 = as.numeric(death == "1"),
    sex_female = as.numeric(sex == "female"),
    sex_male = as.numeric(sex == "male"),
    dzgroup_A = as.numeric(dzgroup == "ARF/MOSF w/Sepsis"),
    dzgroup_B = as.numeric(dzgroup == "COPD"),
    dzgroup_C = as.numeric(dzgroup == "CHF"),
    dzgroup_D = as.numeric(dzgroup == "Cirrhosis"),
    dzgroup_E = as.numeric(dzgroup == "Coma"),
    dzgroup_F = as.numeric(dzgroup == "Colon Cancer"),
    dzgroup_G = as.numeric(dzgroup == "Lung Cancer"),
    dzgroup_H = as.numeric(dzgroup == "MOSF w/Malig"),
    income_A = as.numeric(income == "<$11k"),
    income_B = as.numeric(income == "$11-$25k"),
    income_C = as.numeric(income == "$25-$50k"),
    income_D = as.numeric(income == ">$50k")
  ) %>%
  select(-death, -sex, -dzgroup, -income)  # Supprimer les variables catégorielles originales









# Utilisation de la fonction ampute  (MAR)

set.seed(123)
mardata <- ampute(data_dummies,
                  prop=0.3,
                  patterns = matrix(c(rep(1,ncol(data_dummies)-4),rep(0,4)), 
                                    nrow = 1), 
                  mech = "MAR", 
                  weights = c(rep(1,ncol(data_dummies)-4),rep(0,4)))$amp


mardata <- mardata %>%
  mutate(
    death = case_when(
      death_0 == 1 ~ "0",
      death_1 == 1 ~ "1",
      TRUE ~ NA_character_
    ),
    sex = case_when(
      sex_female == 1 ~ "female",
      sex_male == 1 ~ "male",
      TRUE ~ NA_character_
    ),
    dzgroup = case_when(
      dzgroup_A == 1 ~ "ARF/MOSF w/Sepsis",
      dzgroup_B == 1 ~ "COPD",
      dzgroup_C == 1 ~ "CHF",
      dzgroup_D == 1 ~ "Cirrhosis",
      dzgroup_E == 1 ~ "Coma",
      dzgroup_F == 1 ~ "Colon Cancer",
      dzgroup_G == 1 ~ "Lung Cancer",
      dzgroup_H == 1 ~  "MOSF w/Malig",
      TRUE ~ NA_character_
    ),
    income = case_when(
      income_A == 1 ~ "<$11k",
      income_B == 1 ~ "$11-$25k",
      income_C == 1 ~ "$25-$50k",
      income_D == 1 ~ ">$50k",  
      TRUE ~ NA_character_
    )
  ) %>%
  select(d.time, death, age, sex, income,  dzgroup,num.co, meanbp, hrt, crea, sod, temp)  # Réorganiser les colonnes






mardata$death <- factor(mardata$death, levels = levels(fulldata$death))
mardata$sex <- factor(mardata$sex,levels = levels(fulldata$sex))
mardata$dzgroup <- factor(mardata$dzgroup,levels = levels(fulldata$dzgroup))
mardata$income <- factor(mardata$income,levels = levels(fulldata$income))








## Ajout des termes quadratiques



fulldata$meanbp2 <- fulldata$meanbp^2
fulldata$hrt2 <- fulldata$hrt^2
fulldata$temp2 <- fulldata$temp^2
fulldata$sqrt_crea <- sqrt(fulldata$crea)



mardata$meanbp2 <- mardata$meanbp^2
mardata$hrt2 <- mardata$hrt^2
mardata$temp2 <- mardata$temp^2
mardata$sqrt_crea <- sqrt(mardata$crea)
mardata$R.income <- as.factor(ifelse(is.na(mardata$income),0,1))



### Proportion des observations censurées et manquantes



(sum(fulldata$death ==0)/nrow(fulldata))*100 #  censure
(sum(is.na(mardata$income))/nrow(mardata))*100 # manquante




## Full data (sans valeurs manquantes)






bias_relative <- function(value,hat_estimate){
  return(((hat_estimate - value)/value)*100)
}




full.mod <- coxph(
  formula = Surv(d.time, death == 1) ~ income + sex + sod +  
    temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
    num.co + age +
    num.co:d.time + age:d.time + 
    strata(dzgroup),
  data = fulldata
)



extract_full_mcar_iwp <- function(cox_model) {
  # Vérification
  if (!inherits(cox_model, "coxph")) {
    stop("L'objet fourni n'est pas un modèle de type 'coxph'.")
  }
  
  # Extraire le résumé du modèle
  mod.sum <- summary(cox_model)
  
  # Vérifie si des erreurs robustes sont présentes
  colnames_coef <- colnames(mod.sum$coefficients)
  se_col <- if ("robust se" %in% colnames_coef) "robust se" else "se(coef)"
  
  # Extraire coefficients et SE appropriés
  coef_est <- mod.sum$coefficients[, "coef"]
  se_est   <- mod.sum$coefficients[, se_col]
  
  # Calculs
  lower_ci <- coef_est - qnorm(0.975) * se_est
  upper_ci <- coef_est + qnorm(0.975) * se_est
  p_value  <- 2 * (1 - pnorm(abs(coef_est / se_est)))
  ci_width <- 2 * qnorm(0.975) * se_est
  
  # Construction du tableau
  result <- data.frame(
    "exp(coef)" = exp(coef_est),
    "lower.95"  = exp(lower_ci),
    "upper.95"  = exp(upper_ci),
    "Pr(>|z|)"  = p_value,
    "CI_width"  = ci_width,
    check.names = FALSE
  )
  
  return(result)
}







result.full <- extract_full_mcar_iwp(full.mod)
result.full$bias <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = result.full[,"exp(coef)"])
result.full






## Completes cases anlysis: (MCAR)


mod.mcar <- coxph(
  formula = Surv(d.time, death == 1) ~ income + sex + sod +  
    temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
    num.co + age +
    num.co:d.time + age:d.time + 
    strata(dzgroup),
  data = na.omit(mardata)
)




result.cc <- extract_full_mcar_iwp(mod.mcar)
result.cc$bias <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = result.cc[,"exp(coef)"])
result.cc











### Méthodes sémi-paramétrique: inverse de la probabilité pondérée (MAR)









set.seed(312)
work.model <- glm(R.income ~ d.time + death + age + sex +  sod +  temp +
                    dzgroup + num.co + hrt +crea + meanbp, data = mardata, family = binomial)
predicted <-  pmax(pmin(predict(work.model, type = "response"), 0.99), 0.01)


## paramètre de compromis


# kappa = 1  
# kappa = 0.95
kappa = 0.9



# Poids pondérés pour les observations manquantes selon notre proposition


mardata$w_corrected <- ifelse(
  mardata$R.income == 1,
  1 / predicted, 
  kappa*1 + (1-kappa)*(1 / (1-predicted)))



# Poids classique pour les observation manquantes selon  iwp standard



mardata$w_standard <- ifelse(
  mardata$R.income == 1,
  1 / predicted, 
  1 / (1-predicted))








summary(mardata[mardata$R.income == 0, c("w_corrected", "w_standard")])
summary(mardata[mardata$R.income == 1, c("w_corrected", "w_standard")])



# Disttribution du poids pondérée vs poids standard



p1 <- ggplot(mardata, aes(x = w_corrected, fill = factor(R.income))) +
  geom_histogram(alpha = 0.5, bins = 30) +
  scale_fill_manual(values = c("green", "blue"), labels = c("R.income = 0", "R.income = 1")) +
  labs(title = "Histogram of Corrected Weight by Missing Income Indicator", 
       x = "Weight", y = "Count", fill = "Weight") + 
  theme_minimal(base_size = 10) +
  facet_wrap(~ R.income, scales = "free", 
             labeller = as_labeller(c("0" = "R.income = 0", "1" = "R.income = 1"))) +
  theme(plot.title = element_text(hjust = 0.5, size = 10, face = "bold"))


p2 <- ggplot(mardata, aes(x = w_standard, fill = factor(R.income))) +
  geom_histogram(alpha = 0.5, bins = 30) +
  scale_fill_manual(values = c("orange", "blue"), labels = c("R.income = 0", "R.income = 1")) +
  labs(title = "Histogram of Standard Weight by Missing Income Indicator", 
       x = "Weight", y = "Count", fill = "Weight") + 
  theme_minimal(base_size = 10) +
  facet_wrap(~ R.income, scales = "free", 
             labeller = as_labeller(c("0" = "R.income = 0", "1" = "R.income = 1"))) +
  theme(plot.title = element_text(hjust = 0.5, size = 10, face = "bold"))



gridExtra::grid.arrange(grobs = list( p1,  p2), nrow = 2)








mod.iwp <- coxph(formula = Surv(d.time, death == 1) ~ income + sex + sod +  
                   temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
                   num.co + age +
                   num.co:d.time + age:d.time + 
                   strata(dzgroup), data = na.omit(mardata), weights = w_corrected,robust = TRUE)









result.iwp <- extract_full_mcar_iwp(mod.iwp)
result.iwp$bias <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = result.iwp[,"exp(coef)"])
result.iwp




## Imputation multiple paramétrique (MAR)



mardata$cumhaz <- NA
fit <-  survfit(survival::Surv(d.time, death == 1) ~ 1, data = mardata, type = "fh")
time_indices <- match(mardata$d.time, fit$time)
mardata$cumhaz[!is.na(time_indices)] <- fit$cumhaz[time_indices[!is.na(time_indices)]]




## Nombre d'imputation
M = 100



mice_P_data <- mice(
  data= mardata[,c("cumhaz", "death", "age","sex","income","sod","dzgroup","num.co","hrt","temp","crea","meanbp")],  
  m = M,         
  maxit = 5,      
  method = c("norm","logreg","norm", "logreg", "polyreg", "norm", "polyreg","norm","norm","norm","norm","norm"),
  print = FALSE,
  seed = 10000
)




mice_P_data <-  lapply(1:M, function(m) {
  cbind(mardata[,c("d.time","sqrt_crea","temp2","meanbp2","hrt2")], mice::complete(mice_P_data, m))
})
mice_P_data <- mitml::as.mitml.list(mice_P_data)





miceP.model <- with(mice_P_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                         temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
                                         num.co + age +
                                         num.co:d.time + age:d.time + 
                                         strata(dzgroup)))







## Fonction qui combine les résulats selon la règle de Rubin 


combine_MI <- function(manyresult) {
  # Vérification
  if (!all(sapply(manyresult, inherits, what = "coxph"))) {
    stop("Tous les éléments de 'manyresult' doivent être des objets 'coxph'.")
  }
  
  estimates <- list()
  variances <- list()
  
  for (i in seq_along(manyresult)) {
    mod.sum <- summary(manyresult[[i]])
    
    # Détecter si les erreurs sont robustes
    se_col <- if ("robust se" %in% colnames(mod.sum$coefficients)) {
      "robust se"
    } else {
      "se(coef)"
    }
    
    estimates[[i]] <- mod.sum$coefficients[, "coef"]
    variances[[i]] <- mod.sum$coefficients[, se_col]^2
  }
  
  estimates_mat <- do.call(rbind, estimates)
  variances_mat <- do.call(rbind, variances)
  
  m <- length(manyresult)
  
  Q_bar <- colMeans(estimates_mat)
  U_bar <- colMeans(variances_mat)
  B <- apply(estimates_mat, 2, var) * (m / (m - 1))
  T <- U_bar + (1 + 1 / m) * B
  se <- sqrt(T)
  
  # Degrés de liberté (formule classique de Rubin, 1987)
  df <- (m - 1) * (T / B)^2
  
  # Intervalles de confiance
  CI_low <- Q_bar - qt(0.975, df) * se
  CI_up <- Q_bar + qt(0.975, df) * se
  
  # p-value (z-test approx)
  z <- Q_bar / se
  p_value <- 2 * (1 - pnorm(abs(z)))
  
  result <- data.frame(
    "exp(coef)" = exp(Q_bar),
    "lower.95" = exp(CI_low),
    "upper.95" = exp(CI_up),
    "Pr(>|z|)" = p_value,
    check.names = FALSE,
    row.names = rownames(estimates_mat)
  )
  return(result)
}





miceP.est <- combine_MI(miceP.model)
miceP.est[,"CI_width"] <- miceP.est[,"upper.95"] - miceP.est[,"lower.95"] 
miceP.est[,"bias"] <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = miceP.est[,"exp(coef)"])
rownames(miceP.est) <- rownames(result.full)
miceP.est




## Imputation multiple non paramétrique (MAR)


RF_NP_data <- mice(
  data= mardata[,c("d.time", "death", "age","sex","income","sod","dzgroup","num.co","hrt","temp","crea","meanbp")],  
  m = M,         
  maxit = 5,      
  method = c("rf", "rf", "rf", "rf", "rf", "rf","rf","rf","rf","rf","rf","rf"),
  print = FALSE,
  seed = 10000
)








RF_NP_data <-  lapply(1:M, function(m) {
  cbind(mardata[,c("d.time","sqrt_crea","temp2","meanbp2","hrt2")], mice::complete(RF_NP_data, m))
})
RF_NP_data <- mitml::as.mitml.list(RF_NP_data)



rfNP.model <-  with(RF_NP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                        temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
                                        num.co + age +
                                        num.co:d.time + age:d.time + 
                                        strata(dzgroup)))




rfNP.est <- combine_MI(rfNP.model)
rfNP.est[,"CI_width"] <- rfNP.est[,"upper.95"] - rfNP.est[,"lower.95"] 
rfNP.est[,"bias"] <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = rfNP.est[,"exp(coef)"])
rownames(rfNP.est) <- rownames(result.full)
rfNP.est




# Méthodes hybrides `

## Hybride 1: MI paramétrique et MI non paramétrique (MAR)



P_NP_data <- vector("list", M)
for (i in 1:(M/2)) {
  P_NP_data[[i]] <- mice_P_data[[i]]
  P_NP_data[[i + (M/2)]] <- RF_NP_data[[i]]
}
P_NP_data <- mitml::as.mitml.list(P_NP_data)




P_NP_mod <- with(P_NP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                    temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
                                    num.co + age +
                                    num.co:d.time + age:d.time + 
                                    strata(dzgroup)))



P_NP.est<- combine_MI(P_NP_mod)
P_NP.est[,"CI_width"] <- P_NP.est[,"upper.95"] - P_NP.est[,"lower.95"] 
P_NP.est[,"bias"] <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = P_NP.est[,"exp(coef)"])
rownames(P_NP.est) <- rownames(result.full)
P_NP.est






## Hybride 2: MI paramétrique et IWP (MAR)




MI.P_IWP_data <-  lapply(1:M, function(m) {
  cbind(mice_P_data[[m]], mardata[, c("sqrt_crea","temp2","meanbp2","hrt2", "R.income", "w_corrected", "w_standard")])
})
MI.P_IWP_data <- mitml::as.mitml.list(MI.P_IWP_data)


MI.P_IWP_mod <- with(MI.P_IWP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                            temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
                                            num.co + age +
                                            num.co:d.time + age:d.time + 
                                            strata(dzgroup),weights = w_corrected, robust = TRUE))













P_iwp.est <- combine_MI(MI.P_IWP_mod)
P_iwp.est[,"CI_width"] <- P_iwp.est[,"upper.95"] - P_iwp.est[,"lower.95"] 
P_iwp.est[,"bias"] <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = P_iwp.est[,"exp(coef)"])
rownames(P_iwp.est) <- rownames(result.full)
P_iwp.est




## Hybride 3:  MI non paramétrique et IWP (MAR)

MI.NP_IWP_data <-  lapply(1:M, function(m) {
  cbind(RF_NP_data[[m]], mardata[, c("sqrt_crea","temp2","meanbp2","hrt2","R.income", "w_corrected", "w_standard")])
})

MI.NP_IWP_data <- mitml::as.mitml.list(MI.NP_IWP_data)



MI.NP_IWP_mod <-  with(MI.NP_IWP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                               temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
                                               num.co + age +
                                               num.co:d.time + age:d.time + 
                                               strata(dzgroup),weights = w_corrected, robust = TRUE))



NP_iwp.est <- combine_MI(MI.NP_IWP_mod)
NP_iwp.est[,"CI_width"] <- NP_iwp.est[,"upper.95"] - NP_iwp.est[,"lower.95"] 
NP_iwp.est[,"bias"] <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = NP_iwp.est[,"exp(coef)"])
rownames(NP_iwp.est) <- rownames(result.full)
NP_iwp.est





## Hybride 4: MI paramétrique, MI non paramétrique et IWP (MAR)




P_NP_IWP_data <- lapply(1:M, function(m){
  cbind(P_NP_data[[m]],mardata[, c("sqrt_crea","temp2","meanbp2","hrt2","R.income", "w_corrected", "w_standard")])
})
P_NP_IWP_data <- mitml::as.mitml.list(P_NP_IWP_data)




P_NP_IWP_mod <- with(P_NP_IWP_data, coxph(Surv(d.time, death ==1) ~ income + sex + sod +  
                                            temp + temp2 + meanbp + meanbp2 + hrt + hrt2 + crea + sqrt_crea +
                                            num.co + age +
                                            num.co:d.time + age:d.time + 
                                            strata(dzgroup),weights = w_corrected, robust = TRUE))




P_NP_iwp.est <- combine_MI(P_NP_IWP_mod)
P_NP_iwp.est[,"CI_width"] <- P_NP_iwp.est[,"upper.95"] - P_NP_iwp.est[,"lower.95"] 
P_NP_iwp.est[,"bias"] <- bias_relative(value = result.full[,"exp(coef)"], hat_estimate = P_NP_iwp.est[,"exp(coef)"])
rownames(P_NP_iwp.est) <- rownames(result.full)
P_NP_iwp.est




## Biais relatif en pourcentage

all_bias <- data.frame(Full =  result.full[,"bias"],
                       CC =  result.cc[,"bias"],
                       Iwp =  result.iwp[,"bias"],
                       Mice.P =  miceP.est[,"bias"],
                       RF.NP =  rfNP.est[,"bias"],
                       Hybrid1 =  P_NP.est[,"bias"],
                       Hybrid2 =  P_iwp.est[,"bias"],
                       Hybrid3 = NP_iwp.est[,"bias"],
                       Hybrid4 =  P_NP_iwp.est[,"bias"])

rownames(all_bias) <- rownames(result.full)
knitr::kable(round(all_bias[c("income$11-$25k", "income$25-$50k", "income>$50k","sexmale","age","num.co","crea","hrt","temp","sod","meanbp"),],3))


## Largeur des intervalles de confiance


all_CI_width <- data.frame(Full =  result.full[,"CI_width"],
                           CC =  result.cc[,"CI_width"],
                           Iwp =  result.iwp[,"CI_width"],
                           Mice.P =  miceP.est[,"CI_width"],
                           RF.NP =  rfNP.est[,"CI_width"],
                           Hybrid1 =  P_NP.est[,"CI_width"],
                           Hybrid2 =  P_iwp.est[,"CI_width"],
                           Hybrid3 = NP_iwp.est[,"CI_width"],
                           Hybrid4 =  P_NP_iwp.est[,"CI_width"])

rownames(all_CI_width) <- rownames(result.full)
knitr::kable(round(all_CI_width[c("income$11-$25k", "income$25-$50k", "income>$50k","sexmale","age","num.co","crea","hrt","temp","sod","meanbp"),],3))


tf <- Sys.time()
code_time <- tf - ti
code_time



# sink()



